import 'dart:async';
import 'package:build/build.dart';
import 'package:dart_style/dart_style.dart';
import 'package:glob/glob.dart';

import 'utils.dart';

/// Aggregator builder that finds all @ease generated files
/// and creates a single ease.g.dart file with the Ease root widget.
class AggregatorBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'lib/$lib$': ['lib/ease.g.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final stateClasses = <_StateClassInfo>[];

    // Find only .ease.dart files (not all .g.dart files for performance)
    await for (final input
        in buildStep.findAssets(Glob('lib/**/*.ease.dart'))) {
      final content = await buildStep.readAsString(input);

      // Look for Provider classes generated by EaseGenerator
      final classMatches =
          RegExp(r'class (\w+)Provider extends StatefulWidget')
              .allMatches(content);

      for (final match in classMatches) {
        final providerName = '${match.group(1)!}Provider';
        final className = match.group(1)!;
        final getterName = toCamelCase(className);

        // Get the source file import path
        final relativePath = input.path.replaceFirst('lib/', '');
        final importPath = relativePath.replaceFirst('.ease.dart', '.dart');

        stateClasses.add(_StateClassInfo(
          className: className,
          providerName: providerName,
          getterName: getterName,
          importPath: importPath,
        ));
      }
    }

    if (stateClasses.isEmpty) {
      log.info('No @ease annotated classes found.');
      return;
    }

    // Generate the aggregated file
    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// ignore_for_file: type=lint');
    buffer.writeln();
    buffer.writeln("import 'package:flutter/widgets.dart';");
    buffer.writeln("import 'package:ease/ease.dart';");
    buffer.writeln();

    // Import all state files (which include their .g.dart parts)
    for (final state in stateClasses) {
      buffer.writeln("import '${state.importPath}';");
    }
    buffer.writeln();

    // Generate Ease root widget
    buffer.writeln('// ============================================');
    buffer.writeln('// Ease Root Widget');
    buffer.writeln('// ============================================');
    buffer.writeln();
    buffer.writeln('/// Root widget that provides all @ease states to descendants.');
    buffer.writeln('///');
    buffer.writeln('/// Wrap your app with this widget to enable state access:');
    buffer.writeln('/// ```dart');
    buffer.writeln('/// void main() => runApp(Ease(child: MyApp()));');
    buffer.writeln('/// ```');
    buffer.writeln('class Ease extends StatelessWidget {');
    buffer.writeln('  final Widget child;');
    buffer.writeln();
    buffer.writeln('  const Ease({super.key, required this.child});');
    buffer.writeln();
    buffer.writeln('  static final _providers = <Widget Function(Widget)>[');
    for (final state in stateClasses) {
      buffer.writeln('    (child) => ${state.providerName}(child: child),');
    }
    buffer.writeln('  ];');
    buffer.writeln();
    buffer.writeln('  @override');
    buffer.writeln('  Widget build(BuildContext context) {');
    buffer.writeln('    return _providers.fold(child, (child, provider) => provider(child));');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Generate generic get<T>() extension
    buffer.writeln('// ============================================');
    buffer.writeln('// Generic Context Extension');
    buffer.writeln('// ============================================');
    buffer.writeln();
    buffer.writeln('/// Extension providing generic access to all @ease states.');
    buffer.writeln('extension EaseContext on BuildContext {');
    buffer.writeln('  /// Gets a state by type and subscribes to changes.');
    buffer.writeln('  ///');
    buffer.writeln('  /// Example:');
    buffer.writeln('  /// ```dart');
    buffer.writeln('  /// final counter = context.get<CounterState>();');
    buffer.writeln('  /// ```');
    buffer.writeln('  T get<T extends StateNotifier>() {');
    for (final state in stateClasses) {
      buffer.writeln(
          '    if (T == ${state.className}) return ${state.getterName} as T;');
    }
    buffer.writeln(
        "    throw StateError('No provider found for \$T. Did you add @ease annotation?');");
    buffer.writeln('  }');
    buffer.writeln();
    buffer.writeln('  /// Gets a state by type without subscribing to changes.');
    buffer.writeln('  ///');
    buffer.writeln('  /// Example:');
    buffer.writeln('  /// ```dart');
    buffer.writeln('  /// final counter = context.read<CounterState>();');
    buffer.writeln('  /// ```');
    buffer.writeln('  T read<T extends StateNotifier>() {');
    for (final state in stateClasses) {
      buffer.writeln(
          '    if (T == ${state.className}) return read${state.className}() as T;');
    }
    buffer.writeln(
        "    throw StateError('No provider found for \$T. Did you add @ease annotation?');");
    buffer.writeln('  }');
    buffer.writeln('}');

    // Format and write the output
    // Use try-catch for backwards compatibility with older dart_style versions
    final formatted = _formatDartCode(buffer.toString());

    final outputId = AssetId(
      buildStep.inputId.package,
      'lib/ease.g.dart',
    );
    await buildStep.writeAsString(outputId, formatted);

    log.info('Generated ease.g.dart with ${stateClasses.length} states');
  }

  /// Format Dart code
  String _formatDartCode(String code) {
    try {
      final formatter =
          DartFormatter(languageVersion: DartFormatter.latestLanguageVersion);
      return formatter.format(code);
    } catch (_) {
      // If formatting fails, return unformatted code
      return code;
    }
  }
}

class _StateClassInfo {
  final String className;
  final String providerName;
  final String getterName;
  final String importPath;

  _StateClassInfo({
    required this.className,
    required this.providerName,
    required this.getterName,
    required this.importPath,
  });
}
